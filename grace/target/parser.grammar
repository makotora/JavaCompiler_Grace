Package compiler;

Helpers
  //white space
  vt = 9; //vertical tab
  lf = 10; //line feed
  ht = 11; //horizontal tab
  ff = 12; //form feed
  cr = 13; //carriage return
  sp = ' '; //space
  eol = cr | lf || cr lf; //end of line
  whitespace = (sp | ht | ff | eol | vt)*;

  squote = '''; //single quote
  dquote = '"'; //double quote
  backslash = '\';

  //others
  anything = [0 .. 0xffff];
  not_eol = [anything - [cr + lf]];
  dollar = '$';
  not_dollar = [anything - dollar];
  operands = '+' | '-' | '*' | 'div' | 'mod';

  digit = ['0' .. '9'];
  number = digit+;
  hex = [digit + [['a' .. 'f'] + ['A' .. 'F']]];
  nondigit = [ '_' + [['a' .. 'z'] + ['A' .. 'Z']]];
  letter = [['a' .. 'z'] + ['A' .. 'Z']];
  char = [not_eol - [[squote + dquote] + backslash]];
  esc_seq = '\n' | '\t' | '\r' | '\0' | '\\' | '\' ''' | '\"' | '\x' hex hex;

  separator = ',' |  whitespace;
  type = 'int' | 'char';


Tokens
  //keywords
  and = 'and';
  char = 'char' ;
  div = 'div';
  do = 'do';
  else = 'else';
  fun = 'fun';
  if = 'if';
  int = 'int';
  mod = 'mod';
  not = 'not';
  nothing = 'nothing';
  or = 'or';
  ref = 'ref';
  return = 'return';
  then = 'then';
  var = 'var';
  while = 'while';

  //others
  comment = '$$' not_dollar* '$' (not_dollar+ '$')* '$';
  simple_com = '$' not_eol* eol; //one line comment
  id = letter (digit | nondigit )*; //var or fun names
  number = number;
  error_number = digit+ nondigit+;

  single_char = ''' char ''' | ''' esc_seq ''';
  string = '"' (char | esc_seq)+ '"';

  whitespace = whitespace;

  //separators
  lpar = '(';
  rpar = ')';
  lbrack = '[';
  rbrack = ']';
  lbrace = '{';
  rbrace = '}';
  comma = ',';
  semicolon = ';';
  colon = ':';
  assign = '<-';

  //math
  plus = '+';
  minus = '-';
  mult = '*';

  //comparisons
  eq = '=';
  neq = '#';
  leq = '<=';
  geq = '>=';
  lt = '<';
  gt = '>';

Ignored Tokens
  whitespace,
  simple_com,
  comment;

Productions
  program = func_def;

  //types
  data_type = {int} int
            | {char} char;
  type      = data_type array_brack_list?;
  ret_type  = {something} data_type
            | {nothing} nothing;
  fpar_type = {stat} data_type empty_brack? array_brack_list?;
  empty_brack = lbrack rbrack;
  array_brack_list = lbrack number rbrack array_brack_tail*;
  array_brack_tail = lbrack number rbrack;

  //var definition
  var_def = var id_list colon type semicolon;
  id_list = id id_list_tail*;
  id_list_tail = comma id;

  //function header
  header    = fun id lpar fpar_def_list? rpar colon ret_type;
  fpar_def_list = fpar_def par_list_tail*;
  fpar_def = ref? id_list colon fpar_type;
  par_list_tail = semicolon fpar_def;

  //definitions-declarations
  func_def = header local_def_list? block;
  func_decl = header semicolon;
  local_def_list = {fdef} func_def local_def_tail*
            | {fdec} func_decl local_def_tail*
            | {vdef} var_def local_def_tail*;
  local_def_tail = {fdef} func_def
            | {fdec} func_decl
            | {vdef} var_def;

  //things we need to define statements
  func_call = id lpar expr_list? rpar;
  expr_list = expr expr_tail*;
  expr_tail = comma expr;

  lvalue = {id} id
          | {string} string
          | {lvalue} lvalue lbrack expr rbrack;

    //Expression
    expr = {term} term
         | {add}  expr plus term
         |{sub}  expr minus term;
    term = {fact} fact
         |{mult} term mult fact
         |{div}  term div fact
         |{mod} term mod fact;
    fact = {signed} signed_expr
         | {number} number
         | {char} single_char
         | {fcall} func_call
         | {lval} lvalue
         | {paren} lpar expr rpar;

    //Signed number
    signed_expr = {positive} plus fact
    | {negative} minus fact;

    //Conditions
    cond = {cterm} cterm
         | {or} cond or cterm;

    cterm = {cfact} cfact
          | {and} cterm and cfact;

    cfact = {comp} comp
          | {not} not cfact;

    comp = {eq} [expr1]:expr eq [expr2]:expr
         | {neq} [expr1]:expr neq [expr2]:expr
         | {leq} [expr1]:expr leq [expr2]:expr
         | {geq} [expr1]:expr geq [expr2]:expr
         | {lt} [expr1]:expr lt [expr2]:expr
         | {gt} [expr1]:expr gt [expr2]:expr
         | {cparen} lpar cond rpar;


    //block contains statements
    block = lbrace stmt* rbrace;

    //Statements

    noop = semicolon;
    assignment = lvalue assign expr semicolon;
    return_stmt = return expr? semicolon;

    stmt = {noop} noop
         | {assignment} assignment
         | {block} block
         | {fcall} func_call semicolon
         | {if} if_stmt
         | {while} while_stmt
         | {return_stmt} return_stmt;

    if_stmt = {no_else} if cond then_stmt
            | {else} if cond then_stmt_welse else_stmt;

    then_stmt = then stmt;
    then_stmt_welse = then stmt_with_else;
    else_stmt = else stmt;

    stmt_with_else = {noop} noop
                   | {assignment} assignment
                   | {block} block
                   | {fcall} func_call semicolon
                   | {if} if_else_stmt
                   | {while} while_with_else
                   | {return} return_stmt;

    if_else_stmt = if cond then_stmt_welse else_stmt_with_else;

    else_stmt_with_else = else stmt_with_else;

    while_stmt = {no_else} while cond do_stmt;

    while_with_else = {while_else} while cond do_stmt_welse;

    do_stmt = do stmt;
    do_stmt_welse = do stmt_with_else;
