Package compiler;

Helpers
  //white space
  vt = 9; //vertical tab
  lf = 10; //line feed
  ht = 11; //horizontal tab
  ff = 12; //form feed
  cr = 13; //carriage return
  sp = ' '; //space
  eol = cr | lf || cr lf; //end of line
  whitespace = (sp | ht | ff | eol)*;

  squote = '''; //single quote
  dquote = '"'; //double quote
  backslash = '\';

  //others
  anything = [0 .. 0xffff];
  not_eol = [anything - [cr + lf]];
  dollar = '$';
  not_dollar = [anything - dollar];
  operands = '+' | '-' | '*' | 'div' | 'mod';

  digit = ['0' .. '9'];
  number = digit+;
  hex = [digit + [['a' .. 'f'] + ['A' .. 'F']]];
  nondigit = [ '_' + [['a' .. 'z'] + ['A' .. 'Z']]];
  letter = [['a' .. 'z'] + ['A' .. 'Z']];
  char = [not_eol - [[squote + dquote] + backslash]];
  esc_seq = '\n' | '\t' | '\r' | '\0' | '\\' | '\' ''' | '\"' | '\x' hex hex;

  separator = ',' |  whitespace;
  type = 'int' | 'char';


Tokens
  //keywords
  and = 'and';
  char = 'char' ;
  div = 'div';
  do = 'do';
  else = 'else';
  fun = 'fun';
  if = 'if';
  int = 'int';
  mod = 'mod';
  not = 'not';
  nothing = 'nothing';
  or = 'or';
  ref = 'ref';
  return = 'return';
  then = 'then';
  var = 'var';
  while = 'while';

  //others
  comment = '$$' not_dollar* '$' (not_dollar+ '$')* '$';
  simple_com = '$' not_eol* eol; //one line comment
  id = letter (digit | nondigit )*; //var or fun names
  number = number;

  single_char = ''' char ''' | ''' esc_seq ''';
  string = '"' (char | esc_seq)+ '"';

  whitespace = whitespace;

  //separators
  lpar = '(';
  rpar = ')';
  lbrack = '[';
  rbrack = ']';
  lbrace = '{';
  rbrace = '}';
  comma = ',';
  semicolon = ';';
  colon = ':';
  assign = '<-';

  //math
  plus = '+';
  minus = '-';
  mult = '*';

  //comparisons
  eq = '=';
  neq = '#';
  leq = '<=';
  geq = '>=';
  lt = '<';
  gt = '>';

Ignored Tokens
  whitespace,
  simple_com,
  comment;

Productions
  program = func_def;

  //types
  data_type = {int} int
            | {char} char;
  type      = data_type array_brack*;
  ret_type  = {something} data_type
            | {nothing} nothing;
  fpar_type = {stat} data_type empty_brack? array_brack*;
  empty_brack = lbrack rbrack;
  array_brack = lbrack number rbrack;

  //var definition
  var_def = var id_list colon type semicolon;
  id_list = id id_list_tail*;
  id_list_tail = comma id;

  //function header
  header    = fun id lpar fpar_def_list? rpar colon ret_type;
  fpar_def_list = fpar_def par_list_tail*;
  fpar_def = ref? id_list colon fpar_type;
  par_list_tail = semicolon fpar_def;

  //definitions-declarations
  func_def = header local_def* block;
  func_decl = header semicolon;
  local_def = {fdef} func_def
            | {fdec} func_decl
            | {vdef} var_def;

  //block contains statements (defined later)
  block = lbrace stmt* rbrace;

  //things we need to define statements
  func_call = id lpar expr_list? rpar;
  expr_list = expr expr_tail*;
  expr_tail = comma expr;

  lvalue = {id} id
          | {string} string
          | {lvalue} lvalue lbrack expr rbrack;

    //Expression
    expr = {term} term
         | {add}  expr plus term
         |{sub}  expr minus term;
    term = {fact} fact
         |{mult} term mult fact
         |{div}  term div fact;
    fact = {number} number
         | {char} single_char
         | {fcall} func_call
         | {lval} lvalue
         | {paren} lpar expr rpar;

    //Conditions
    cond = {cterm} cterm
         | {or} cond or cterm;

    cterm = {cfact} cfact
          | {and} cterm and cfact;

    cfact = {comp} comp
          | {not} not cfact;

    comp = {eq} expr eq expr2
         | {neq} expr neq expr2
         | {leq} expr leq expr2
         | {geq} expr geq expr2
         | {lt} expr lt expr2
         | {gt} expr gt expr2
         | {cparen} lpar cond rpar;

    expr2 = expr;

    //Statements
    stmt = {noop} semicolon
          | {assignment} lvalue assign expr semicolon
          | {block} block
          | {fcall} func_call semicolon;
