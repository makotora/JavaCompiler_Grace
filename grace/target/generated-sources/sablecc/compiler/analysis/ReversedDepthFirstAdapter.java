/* This file was generated by SableCC (http://www.sablecc.org/). */

package compiler.analysis;

import java.util.*;
import compiler.node.*;

public class ReversedDepthFirstAdapter extends AnalysisAdapter
{
    public void inStart(Start node)
    {
        defaultIn(node);
    }

    public void outStart(Start node)
    {
        defaultOut(node);
    }

    public void defaultIn(@SuppressWarnings("unused") Node node)
    {
        // Do nothing
    }

    public void defaultOut(@SuppressWarnings("unused") Node node)
    {
        // Do nothing
    }

    @Override
    public void caseStart(Start node)
    {
        inStart(node);
        node.getEOF().apply(this);
        node.getPFuncDef().apply(this);
        outStart(node);
    }

    public void inAFuncDef(AFuncDef node)
    {
        defaultIn(node);
    }

    public void outAFuncDef(AFuncDef node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAFuncDef(AFuncDef node)
    {
        inAFuncDef(node);
        if(node.getBlock() != null)
        {
            node.getBlock().apply(this);
        }
        {
            List<PLocalDef> copy = new ArrayList<PLocalDef>(node.getLocalDef());
            Collections.reverse(copy);
            for(PLocalDef e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getRetType() != null)
        {
            node.getRetType().apply(this);
        }
        {
            List<PPar> copy = new ArrayList<PPar>(node.getPar());
            Collections.reverse(copy);
            for(PPar e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getId() != null)
        {
            node.getId().apply(this);
        }
        outAFuncDef(node);
    }

    public void inASmthRetType(ASmthRetType node)
    {
        defaultIn(node);
    }

    public void outASmthRetType(ASmthRetType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASmthRetType(ASmthRetType node)
    {
        inASmthRetType(node);
        if(node.getType() != null)
        {
            node.getType().apply(this);
        }
        outASmthRetType(node);
    }

    public void inANothingRetType(ANothingRetType node)
    {
        defaultIn(node);
    }

    public void outANothingRetType(ANothingRetType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANothingRetType(ANothingRetType node)
    {
        inANothingRetType(node);
        if(node.getNothing() != null)
        {
            node.getNothing().apply(this);
        }
        outANothingRetType(node);
    }

    public void inAIntType(AIntType node)
    {
        defaultIn(node);
    }

    public void outAIntType(AIntType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIntType(AIntType node)
    {
        inAIntType(node);
        if(node.getInt() != null)
        {
            node.getInt().apply(this);
        }
        outAIntType(node);
    }

    public void inACharType(ACharType node)
    {
        defaultIn(node);
    }

    public void outACharType(ACharType node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACharType(ACharType node)
    {
        inACharType(node);
        if(node.getChar() != null)
        {
            node.getChar().apply(this);
        }
        outACharType(node);
    }

    public void inAPar(APar node)
    {
        defaultIn(node);
    }

    public void outAPar(APar node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAPar(APar node)
    {
        inAPar(node);
        {
            List<TNumber> copy = new ArrayList<TNumber>(node.getNumber());
            Collections.reverse(copy);
            for(TNumber e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getLbrack() != null)
        {
            node.getLbrack().apply(this);
        }
        if(node.getType() != null)
        {
            node.getType().apply(this);
        }
        {
            List<TId> copy = new ArrayList<TId>(node.getId());
            Collections.reverse(copy);
            for(TId e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getRef() != null)
        {
            node.getRef().apply(this);
        }
        outAPar(node);
    }

    public void inAFdefLocalDef(AFdefLocalDef node)
    {
        defaultIn(node);
    }

    public void outAFdefLocalDef(AFdefLocalDef node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAFdefLocalDef(AFdefLocalDef node)
    {
        inAFdefLocalDef(node);
        if(node.getFuncDef() != null)
        {
            node.getFuncDef().apply(this);
        }
        outAFdefLocalDef(node);
    }

    public void inAFdeclLocalDef(AFdeclLocalDef node)
    {
        defaultIn(node);
    }

    public void outAFdeclLocalDef(AFdeclLocalDef node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAFdeclLocalDef(AFdeclLocalDef node)
    {
        inAFdeclLocalDef(node);
        if(node.getFuncDecl() != null)
        {
            node.getFuncDecl().apply(this);
        }
        outAFdeclLocalDef(node);
    }

    public void inAVdefLocalDef(AVdefLocalDef node)
    {
        defaultIn(node);
    }

    public void outAVdefLocalDef(AVdefLocalDef node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAVdefLocalDef(AVdefLocalDef node)
    {
        inAVdefLocalDef(node);
        if(node.getVarDef() != null)
        {
            node.getVarDef().apply(this);
        }
        outAVdefLocalDef(node);
    }

    public void inAFuncDecl(AFuncDecl node)
    {
        defaultIn(node);
    }

    public void outAFuncDecl(AFuncDecl node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAFuncDecl(AFuncDecl node)
    {
        inAFuncDecl(node);
        if(node.getRetType() != null)
        {
            node.getRetType().apply(this);
        }
        {
            List<PPar> copy = new ArrayList<PPar>(node.getPar());
            Collections.reverse(copy);
            for(PPar e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getId() != null)
        {
            node.getId().apply(this);
        }
        outAFuncDecl(node);
    }

    public void inAVarDef(AVarDef node)
    {
        defaultIn(node);
    }

    public void outAVarDef(AVarDef node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAVarDef(AVarDef node)
    {
        inAVarDef(node);
        {
            List<TNumber> copy = new ArrayList<TNumber>(node.getNumber());
            Collections.reverse(copy);
            for(TNumber e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getType() != null)
        {
            node.getType().apply(this);
        }
        {
            List<TId> copy = new ArrayList<TId>(node.getId());
            Collections.reverse(copy);
            for(TId e : copy)
            {
                e.apply(this);
            }
        }
        outAVarDef(node);
    }

    public void inABlock(ABlock node)
    {
        defaultIn(node);
    }

    public void outABlock(ABlock node)
    {
        defaultOut(node);
    }

    @Override
    public void caseABlock(ABlock node)
    {
        inABlock(node);
        {
            List<PStatement> copy = new ArrayList<PStatement>(node.getStatement());
            Collections.reverse(copy);
            for(PStatement e : copy)
            {
                e.apply(this);
            }
        }
        outABlock(node);
    }

    public void inAFuncCall(AFuncCall node)
    {
        defaultIn(node);
    }

    public void outAFuncCall(AFuncCall node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAFuncCall(AFuncCall node)
    {
        inAFuncCall(node);
        {
            List<PExpr> copy = new ArrayList<PExpr>(node.getExpr());
            Collections.reverse(copy);
            for(PExpr e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getId() != null)
        {
            node.getId().apply(this);
        }
        outAFuncCall(node);
    }

    public void inAIdLvalue(AIdLvalue node)
    {
        defaultIn(node);
    }

    public void outAIdLvalue(AIdLvalue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIdLvalue(AIdLvalue node)
    {
        inAIdLvalue(node);
        {
            List<PExpr> copy = new ArrayList<PExpr>(node.getExpr());
            Collections.reverse(copy);
            for(PExpr e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getId() != null)
        {
            node.getId().apply(this);
        }
        outAIdLvalue(node);
    }

    public void inAStringLvalue(AStringLvalue node)
    {
        defaultIn(node);
    }

    public void outAStringLvalue(AStringLvalue node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAStringLvalue(AStringLvalue node)
    {
        inAStringLvalue(node);
        {
            List<PExpr> copy = new ArrayList<PExpr>(node.getExpr());
            Collections.reverse(copy);
            for(PExpr e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getString() != null)
        {
            node.getString().apply(this);
        }
        outAStringLvalue(node);
    }

    public void inANoopStatement(ANoopStatement node)
    {
        defaultIn(node);
    }

    public void outANoopStatement(ANoopStatement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANoopStatement(ANoopStatement node)
    {
        inANoopStatement(node);
        if(node.getSemicolon() != null)
        {
            node.getSemicolon().apply(this);
        }
        outANoopStatement(node);
    }

    public void inAAssignmentStatement(AAssignmentStatement node)
    {
        defaultIn(node);
    }

    public void outAAssignmentStatement(AAssignmentStatement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAssignmentStatement(AAssignmentStatement node)
    {
        inAAssignmentStatement(node);
        if(node.getExpr() != null)
        {
            node.getExpr().apply(this);
        }
        if(node.getLvalue() != null)
        {
            node.getLvalue().apply(this);
        }
        outAAssignmentStatement(node);
    }

    public void inABlockStatement(ABlockStatement node)
    {
        defaultIn(node);
    }

    public void outABlockStatement(ABlockStatement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseABlockStatement(ABlockStatement node)
    {
        inABlockStatement(node);
        if(node.getBlock() != null)
        {
            node.getBlock().apply(this);
        }
        outABlockStatement(node);
    }

    public void inAFcallStatement(AFcallStatement node)
    {
        defaultIn(node);
    }

    public void outAFcallStatement(AFcallStatement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAFcallStatement(AFcallStatement node)
    {
        inAFcallStatement(node);
        if(node.getFuncCall() != null)
        {
            node.getFuncCall().apply(this);
        }
        outAFcallStatement(node);
    }

    public void inAIfElseStatement(AIfElseStatement node)
    {
        defaultIn(node);
    }

    public void outAIfElseStatement(AIfElseStatement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAIfElseStatement(AIfElseStatement node)
    {
        inAIfElseStatement(node);
        if(node.getElse() != null)
        {
            node.getElse().apply(this);
        }
        if(node.getThen() != null)
        {
            node.getThen().apply(this);
        }
        if(node.getCond() != null)
        {
            node.getCond().apply(this);
        }
        outAIfElseStatement(node);
    }

    public void inAWhileStatement(AWhileStatement node)
    {
        defaultIn(node);
    }

    public void outAWhileStatement(AWhileStatement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAWhileStatement(AWhileStatement node)
    {
        inAWhileStatement(node);
        if(node.getStatement() != null)
        {
            node.getStatement().apply(this);
        }
        if(node.getCond() != null)
        {
            node.getCond().apply(this);
        }
        outAWhileStatement(node);
    }

    public void inAReturnStatement(AReturnStatement node)
    {
        defaultIn(node);
    }

    public void outAReturnStatement(AReturnStatement node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAReturnStatement(AReturnStatement node)
    {
        inAReturnStatement(node);
        if(node.getExpr() != null)
        {
            node.getExpr().apply(this);
        }
        outAReturnStatement(node);
    }

    public void inAAddExpr(AAddExpr node)
    {
        defaultIn(node);
    }

    public void outAAddExpr(AAddExpr node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAddExpr(AAddExpr node)
    {
        inAAddExpr(node);
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        outAAddExpr(node);
    }

    public void inASubExpr(ASubExpr node)
    {
        defaultIn(node);
    }

    public void outASubExpr(ASubExpr node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASubExpr(ASubExpr node)
    {
        inASubExpr(node);
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        outASubExpr(node);
    }

    public void inAMultExpr(AMultExpr node)
    {
        defaultIn(node);
    }

    public void outAMultExpr(AMultExpr node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAMultExpr(AMultExpr node)
    {
        inAMultExpr(node);
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        outAMultExpr(node);
    }

    public void inADivExpr(ADivExpr node)
    {
        defaultIn(node);
    }

    public void outADivExpr(ADivExpr node)
    {
        defaultOut(node);
    }

    @Override
    public void caseADivExpr(ADivExpr node)
    {
        inADivExpr(node);
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        outADivExpr(node);
    }

    public void inAModExpr(AModExpr node)
    {
        defaultIn(node);
    }

    public void outAModExpr(AModExpr node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAModExpr(AModExpr node)
    {
        inAModExpr(node);
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        outAModExpr(node);
    }

    public void inANumberExpr(ANumberExpr node)
    {
        defaultIn(node);
    }

    public void outANumberExpr(ANumberExpr node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANumberExpr(ANumberExpr node)
    {
        inANumberExpr(node);
        if(node.getNumber() != null)
        {
            node.getNumber().apply(this);
        }
        {
            List<PSign> copy = new ArrayList<PSign>(node.getSign());
            Collections.reverse(copy);
            for(PSign e : copy)
            {
                e.apply(this);
            }
        }
        outANumberExpr(node);
    }

    public void inACharExpr(ACharExpr node)
    {
        defaultIn(node);
    }

    public void outACharExpr(ACharExpr node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACharExpr(ACharExpr node)
    {
        inACharExpr(node);
        if(node.getSingleChar() != null)
        {
            node.getSingleChar().apply(this);
        }
        outACharExpr(node);
    }

    public void inAFcallExpr(AFcallExpr node)
    {
        defaultIn(node);
    }

    public void outAFcallExpr(AFcallExpr node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAFcallExpr(AFcallExpr node)
    {
        inAFcallExpr(node);
        if(node.getFuncCall() != null)
        {
            node.getFuncCall().apply(this);
        }
        {
            List<PSign> copy = new ArrayList<PSign>(node.getSign());
            Collections.reverse(copy);
            for(PSign e : copy)
            {
                e.apply(this);
            }
        }
        outAFcallExpr(node);
    }

    public void inALvalueExpr(ALvalueExpr node)
    {
        defaultIn(node);
    }

    public void outALvalueExpr(ALvalueExpr node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALvalueExpr(ALvalueExpr node)
    {
        inALvalueExpr(node);
        if(node.getLvalue() != null)
        {
            node.getLvalue().apply(this);
        }
        {
            List<PSign> copy = new ArrayList<PSign>(node.getSign());
            Collections.reverse(copy);
            for(PSign e : copy)
            {
                e.apply(this);
            }
        }
        outALvalueExpr(node);
    }

    public void inASignedExpr(ASignedExpr node)
    {
        defaultIn(node);
    }

    public void outASignedExpr(ASignedExpr node)
    {
        defaultOut(node);
    }

    @Override
    public void caseASignedExpr(ASignedExpr node)
    {
        inASignedExpr(node);
        if(node.getExpr() != null)
        {
            node.getExpr().apply(this);
        }
        {
            List<PSign> copy = new ArrayList<PSign>(node.getSign());
            Collections.reverse(copy);
            for(PSign e : copy)
            {
                e.apply(this);
            }
        }
        outASignedExpr(node);
    }

    public void inAPositiveSign(APositiveSign node)
    {
        defaultIn(node);
    }

    public void outAPositiveSign(APositiveSign node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAPositiveSign(APositiveSign node)
    {
        inAPositiveSign(node);
        if(node.getPlus() != null)
        {
            node.getPlus().apply(this);
        }
        outAPositiveSign(node);
    }

    public void inANegativeSign(ANegativeSign node)
    {
        defaultIn(node);
    }

    public void outANegativeSign(ANegativeSign node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANegativeSign(ANegativeSign node)
    {
        inANegativeSign(node);
        if(node.getMinus() != null)
        {
            node.getMinus().apply(this);
        }
        outANegativeSign(node);
    }

    public void inAOrCond(AOrCond node)
    {
        defaultIn(node);
    }

    public void outAOrCond(AOrCond node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAOrCond(AOrCond node)
    {
        inAOrCond(node);
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        outAOrCond(node);
    }

    public void inAAndCond(AAndCond node)
    {
        defaultIn(node);
    }

    public void outAAndCond(AAndCond node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAndCond(AAndCond node)
    {
        inAAndCond(node);
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        outAAndCond(node);
    }

    public void inANotCond(ANotCond node)
    {
        defaultIn(node);
    }

    public void outANotCond(ANotCond node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANotCond(ANotCond node)
    {
        inANotCond(node);
        if(node.getCond() != null)
        {
            node.getCond().apply(this);
        }
        outANotCond(node);
    }

    public void inAEqCond(AEqCond node)
    {
        defaultIn(node);
    }

    public void outAEqCond(AEqCond node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAEqCond(AEqCond node)
    {
        inAEqCond(node);
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        outAEqCond(node);
    }

    public void inANeqCond(ANeqCond node)
    {
        defaultIn(node);
    }

    public void outANeqCond(ANeqCond node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANeqCond(ANeqCond node)
    {
        inANeqCond(node);
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        outANeqCond(node);
    }

    public void inALeqCond(ALeqCond node)
    {
        defaultIn(node);
    }

    public void outALeqCond(ALeqCond node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALeqCond(ALeqCond node)
    {
        inALeqCond(node);
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        outALeqCond(node);
    }

    public void inAGeqCond(AGeqCond node)
    {
        defaultIn(node);
    }

    public void outAGeqCond(AGeqCond node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAGeqCond(AGeqCond node)
    {
        inAGeqCond(node);
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        outAGeqCond(node);
    }

    public void inALtCond(ALtCond node)
    {
        defaultIn(node);
    }

    public void outALtCond(ALtCond node)
    {
        defaultOut(node);
    }

    @Override
    public void caseALtCond(ALtCond node)
    {
        inALtCond(node);
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        outALtCond(node);
    }

    public void inAGtCond(AGtCond node)
    {
        defaultIn(node);
    }

    public void outAGtCond(AGtCond node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAGtCond(AGtCond node)
    {
        inAGtCond(node);
        if(node.getRight() != null)
        {
            node.getRight().apply(this);
        }
        if(node.getLeft() != null)
        {
            node.getLeft().apply(this);
        }
        outAGtCond(node);
    }
}
